var _ 					= require('underscore');

var indicators = {};
indicators.D = 1;
indicators.O = 1;
indicators.H = 2;
indicators.L = 3;
indicators.C = 4;
indicators.V = 5;



/* TradeStudio utils */
var utils = {
	
}

// Convert Yahoo Finance data to compatible data
utils.fromYahoo = function(data) {
	var output = [];
	_.each(data, function(point) {
		output.push([
			new Date(point.date),
			point.open,
			point.high,
			point.low,
			point.close,
			point.volume
		]);
	});
	return output;
}

exports.utils = utils;















indicators.run = function(indicator, data, options) {
	var buffer = indicator(data, options);
	buffer = buffer[0].data;
	
	var l = data.length;
	
	// apply offset
	options.offset = 0-options.offset;
	if (options.offset > 0) {
		for (i=0;i<l-options.offset;i++) {
			buffer[i][1] = buffer[i+options.offset][1];
		}
		for (i=l-options.offset;i<l;i++) {
			buffer[i][1] = 0;
		}
	}
	if (options.offset < 0) {
		for (i=l-1;i>0-options.offset;i--) {
			buffer[i][1] = buffer[i+options.offset][1];
		}
		for (i=0;i<=0-options.offset;i++) {
			buffer[i][1] = 0;
		}
	}
	
	return buffer;
}

indicators.lag = function(data, options) {
	var buffer = data;
	
	var l = data.length;
	
	// apply offset
	options.offset = 0-options.offset;
	if (options.offset > 0) {
		for (i=0;i<l-options.offset;i++) {
			buffer[i][1] = buffer[i+options.offset][1];
		}
		for (i=l-options.offset;i<l;i++) {
			buffer[i][1] = 0;
		}
	}
	if (options.offset < 0) {
		for (i=l-1;i>0-options.offset-1;i--) {
			buffer[i][1] = buffer[i+options.offset][1];
		}
		for (i=0;i<0-options.offset;i++) {
			buffer[i][1] = 0;
		}
	}
	
	return buffer;
}

indicators.pearson = function(data, options) {
	var i,j;
	var l1,l2;
	l1 = data.length;
	l2 = options.data.length;
	var buffer = new Array();
	//console.log("pearson()",data,options);
	var buffer 	= new Array();
	var sum		= {
		x:	0,
		y:	0,
		xy:	0,
		x2:	0,
		y2:	0
	};
	for (i=0;i<l1;i++) {
		for (j=0;j<l2;j++) {
			if (data[i][0] == options.data[j][0]) {
				var temp = {
					t:	data[i][0]*1,
					x:	data[i][1]*1,
					y:	options.data[j][1]*1,
					xy:	data[i][1]*1*options.data[j][1]*1,
					x2:	data[i][1]*1*data[i][1]*1,
					y2:	options.data[j][1]*1*options.data[j][1]*1
				};
				buffer.push(temp);
				sum.x 	+= temp.x;
				sum.y 	+= temp.y;
				sum.xy 	+= temp.xy;
				sum.x2 	+= temp.x2;
				sum.y2 	+= temp.y2;
			}
		}
	}
	//console.log("buffer",buffer.length, sum);
	
	var pearsoncorrelation	= ( (buffer.length*sum.xy)-(sum.x*sum.y) )/( Math.sqrt( ((buffer.length*sum.x2)-(sum.x*sum.x)) * ((buffer.length*sum.y2)-(sum.y*sum.y)) ) );
	
	//console.log("pearsoncorrelation",pearsoncorrelation);
	
	return [{
		data:	buffer,
		score:	pearsoncorrelation,
		name:	"Pearson Correlation",
		type:	"spline"
	}];
};


indicators.fromjs = function(data, options) {
	var i,j,l1,l2;
	l1 = data.length;
	l2 = data[0].length;
	for (i=0;i<l1;i++) {
		for (j=0;j<l2;j++) {
			data[i][j] *= 1;
		}
	}
	return [{
		data:	data,
		name:	"Data",
		type:	"spline"
	}];
};

indicators.use = function(data, options) {
	var i,j,l1,l2;
	l1 = data.length;
	var keys = [];
	for (i=0;i<options.keys.length;i++) {
		keys.push(options.keys[i]);
	}
	l2 = keys.length;
	var buffer = [];
	for (i=0;i<l1;i++) {
		var temp = [];
		for (j=0;j<l2;j++) {
			temp.push(data[i][keys[j]]*1);
		}
		buffer.push(temp);
	}
	return [{
		data:	buffer,
		name:	"Data",
		type:	"spline"
	}];
};

function data_map(x, in_min, in_max, out_min, out_max) {
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

indicators.normalize = function(data, options) {
	var i,j,l1,l2;
	l1 = data.length;
	var keys = [];
	l2 = options.keys.length;
	var buffer = [];
	var max		= -10000000;
	var min		= 10000000;
	var val;
	// get max and min
	for (i=0;i<l1;i++) {
		for (j=0;j<l2;j++) {
			if (options.keys[j].normalize) {
				val = data[i][options.keys[j].key]*1;
				if (val > max) {
					max = val;
				}
				if (val < min) {
					min = val;
				}
			}
			
		}
	}
	for (i=0;i<l1;i++) {
		var temp = [];
		for (j=0;j<l2;j++) {
			if (options.keys[j].normalize) {
				temp.push(
					data_map(data[i][options.keys[j].key]*1, min, max, 0, 100)
				);
			} else {
				temp.push(
					data[i][options.keys[j].key]*1
				);
			}
		}
		buffer.push(temp);
	}
	return [{
		data:	buffer,
		name:	"Data",
		type:	"spline"
	}];
};


indicators.crosscorrelation = function(data, options) {
	
	console.log("options",options);
	
	//
	
	
	
	
	var i;
	var buffer = [];
	var lagged;
	var pearson;
	for (i=options.min;i<=options.max; i++) {
		lagged 	= indicators.lag(options.data2, {offset:-2});
		//console.log("lagged",lagged);
		pearson = indicators.pearson(options.data1, {
			data:	lagged
		});
		if (isNaN(pearson[0].score)) {
			continue;
		}
		buffer.push([i, pearson[0].score]);
	}
	
	return [{
		data:	buffer,
		name:	"Data",
		type:	"spline"
	}];
};

indicators.transform = function(data, options) {
	var i,j,l1,l2;
	l1 = data.length;
	l2 = options.keys.length;
	var buffer = [];
	for (i=0;i<l1;i++) {
		var temp = [];
		for (j=0;j<l2;j++) {
			if (options.keys[j].t) {
				temp.push(options.keys[j].t(data[i][options.keys[j].key], (data[i])));
			} else {
				temp.push(data[i][options.keys[j]]*1);
			}
			
		}
		buffer.push(temp);
	}
	return [{
		data:	buffer,
		name:	"Data",
		type:	"spline"
	}];
};

indicators.cumulativeReturn = function(data, options) {
	var i,j;
	
	options = _.extend({
		axis: 	0,
		name:	"Cummulative Return",
		type:	"spline"
	}, options);
	
	var buffer = new Array();
	var l = data.length;
	var start = data[0][1];
	for (i=0;i<l;i++) {
		buffer[i] = [data[i][0],data[i][1]/start*100];
	}
	
	return [{
		data:	buffer,
		name:	options.name,
		type:	options.type,
		yAxis:	options.axis
	}];
};

indicators.change = function(data, options) {
	var i,j;
	
	options = _.extend({
		axis: 	0,
		name:	"Changes",
		type:	"areaspline",
		offset:	0
	}, options);
	
	var buffer = new Array();
	var l = data.length;
	var start = data[0][1];
	
	buffer[0]		= [data[0][0], 0];
	
	for (i=1;i<l;i++) {
		buffer[i] 	= [
			data[i][0],
			(data[i][1]-data[i-1][1])/data[i][1]*100
		];
	}
	
	// apply offset
	/*options.offset = 0-options.offset;
	if (options.offset > 0) {
		for (i=0;i<l-options.offset;i++) {
			buffer[i][1] = buffer[i+options.offset][1];
		}
		for (i=l-options.offset;i<l;i++) {
			buffer[i][1] = 0;
		}
	}
	if (options.offset < 0) {
		for (i=l-1;i>0-options.offset;i--) {
			buffer[i][1] = buffer[i+options.offset][1];
		}
		for (i=0;i<=0-options.offset;i++) {
			buffer[i][1] = 0;
		}
	}*/
	
	return [{
		data:	buffer,
		name:	options.name,
		type:	options.type,
		yAxis:	options.axis
	}];
};


indicators.SMA = function(data, options) {
	
	options = _.extend({
		period: 	8,
		price: 		indicators.C
	}, options);
	
	var i,j;
	var buffer = new Array();
	var l = data.length-options.period;
	for (i=0;i<l;i++) {
		var tmp = 0;
		for (j=0;j<options.period;j++) {
			tmp += data[i+j][options.price]*1;
		}
		buffer[i] = [data[i][0],tmp/options.period];
	}
	
	return [{
		data:	buffer,
		name:	"SMA("+options.period+")",
		type:	"spline"
	}];
};

indicators.EMA = function(data, options) {
	var i,j;
	var buffer = new Array();
	var pr = 2/(options.period+1);
	var l = data.length-1;
	for (i=l;i>=0;i--) {
		if (!buffer[i+1]) {
			buffer[i] = [data[i][0],data[i][options.price]*1];
		} else {
			buffer[i] = [data[i][0],data[i][options.price]*1*pr+buffer[i+1][1]*(1-pr)];
		}
	}
	
	return [{
		data:	buffer,
		name:	"EMA("+options.period+")",
		type:	"spline"
	}];
}

indicators.LWMA = function(data, options) {
	
	options = _.extend({
		period: 	8,
		price: 		indicators.C
	}, options);
	
	var i,j;
	var buffer = new Array();
	var l = data.length-options.period;
	var debug = new Array();
	for (i=0;i<l;i++) {
		var tmp = 0;
		var m = 0;
		for (j=0;j<options.period;j++) {
			tmp += data[i+j][options.price]*j;
			m += j;
		}
		buffer[i] = [data[i][0],tmp/m];
	}
	
	return [{
		data:	buffer,
		name:	"LWMA("+options.period+")",
		type:	"spline"
	}];
}

indicators.utils = {};
indicators.utils.max = function(data, from, period, price) {
	if (!price) {
		price = indicators.C;
	}
	var max = -100000000;
	for (i=from-period;i<=from;i++) {
		if (data[i][price] > max) {
			max = data[i][price];
		}
	}
	return max;
}
indicators.utils.min = function(data, from, period, price) {
	if (!price) {
		price = indicators.C;
	}
	var min = 100000000;
	for (i=from-period;i<=from;i++) {
		if (data[i][price] < min) {
			min = data[i][price];
		}
	}
	return min;
}
indicators.utils.minPrice = function(data, price) {
	if (!price) {
		price = indicators.C;
	}
	var min = 100000000;
	for (i=0;i<data.length;i++) {
		if (data[i][price] < min) {
			min = data[i][price];
		}
	}
	return min;
}
indicators.utils.maxPrice = function(data, price) {
	if (!price) {
		price = indicators.C;
	}
	var max = -100000000;
	for (i=0;i<data.length;i++) {
		if (data[i][price] > max) {
			max = data[i][price];
		}
	}
	return max;
}

indicators.utils.daysSinceMax = function(data, price) {
	if (!price) {
		price = indicators.H;
	}
	// Find the max
	var max = -100000000;
	var pos = 0;
	for (i=0;i<data.length;i++) {
		if (data[i][price] > max) {
			max = data[i][price];
			pos = i;
		}
	}
	return data.length-pos;
}
indicators.utils.daysSinceMin = function(data, price) {
	if (!price) {
		price = indicators.L;
	}
	// Find the min
	var min = 100000000;
	var pos = 0;
	for (i=0;i<data.length;i++) {
		if (data[i][price] < min) {
			min = data[i][price];
			pos = i;
		}
	}
	return data.length-pos;
}


indicators.aroon = function(data, options) {
	
	options = _.extend({
		period: 	8
	}, options);
	
	var i,j;
	
	var up 			= [];
	var down		= [];
	var upSignal	= [];
	var downSignal	= [];
	
	var l 		= data.length;
	for (i=0;i<l;i++) {
		var _up		= (options.period-indicators.utils.daysSinceMax(data.slice(Math.max(0, i-options.period),i), indicators.H))/options.period*100;
		var _down	= (options.period-indicators.utils.daysSinceMin(data.slice(Math.max(0, i-options.period),i), indicators.H))/options.period*100;
		up.push(
			[data[i][0],_up]
		);
		down.push(
			[data[i][0],_down]
		);
		upSignal.push(
			[data[i][0],Math.max(0,_up-_down)]
		);
		downSignal.push(
			[data[i][0],Math.max(0,_down-_up)]
		);
	}
	
	return [{
		data:	up,
		color:	"17B617",
		name:	"Aroon Up ("+options.period+")",
		type:	"spline"
	},{
		data:	down,
		color:	"B61717",
		name:	"Aroon Down ("+options.period+")",
		type:	"spline"
	},{
		data:	upSignal,
		color:	"A3F3A3",
		name:	"Aroon Up Signal ("+options.period+")",
		type:	"spline",
		signal:	function(v) {
			if (v >= 70) {
				return 1;
			}
			return 0;
		}
	},{
		data:	downSignal,
		color:	"EE7B7B",
		name:	"Aroon Down Signal ("+options.period+")",
		type:	"spline",
		signal:	function(v) {
			if (v >= 70) {
				return -1;
			}
			return 0;
		}
	}];
};

indicators.stochastic = function(data,options) {
	
	options = _.extend({
		period: 	8,
		price: 		indicators.C
	}, options);
	
	var i,j;
	var buffer = new Array();
	var l = data.length;
	for (i=0;i<options.period;i++) {
		buffer[i] = [data[i][0], 0];
	}
	for (i=options.period;i<l;i++) {
		var k = (data[i][indicators.C]-indicators.utils.minPrice(data,indicators.C))/(indicators.utils.maxPrice(data,indicators.H)-indicators.utils.minPrice(data,indicators.C))*100;
		
		buffer[i] = [data[i][0],k];
		
		//buffer[i] = [data[i][0], 100*((data[i][options.price]-indicators.utils.min(data,i,options.period,options.price))/(indicators.utils.max(data,i,options.period,options.price)-indicators.utils.min(data,i,options.period,options.price)))]
		
		
	}
	
	return [{
		data:	buffer,
		name:	"Stochastic("+options.period+")",
		type:	"spline",
		signal:	function(v) {
			if (v >= 70) {
				return -1;
			}
			if (v <= 30) {
				return 1;
			}
			return 0;
		}
	}];
}


indicators.RSI = function(data, options) {
	
	options = _.extend({
		period: 	8
	}, options);
	
	var i,j;
	
	var datasetRSI 	= [];
	
	var l 			= data.length;
	for (i=0;i<l;i++) {
		var RSI = 0;
		
		if (i >= options.period) {
			
			var avgUp 	= 0;
			var sumUp 	= 0;
			var nUp		= 0;
			
			var avgDw 	= 0;
			var sumDw 	= 0;
			var nDw		= 0;
			
			var diff	= 0;
			
			for (j=i-options.period;j<=i;j++) {
				diff = data[j][indicators.O]-data[j][indicators.C];
				if (diff > 0) {
					// down
					sumDw += Math.abs(diff);
					nDw++;
				}
				if (diff < 0) {
					// down
					sumUp += Math.abs(diff);
					nUp++;
				}
			}
			
			avgUp = sumUp/nUp;
			avgDw = sumDw/nDw;
			
			RSI = 100-(100/(1+(avgUp/avgDw)))
			
			datasetRSI.push(
				[data[i][0],RSI]
			);
		} else {
			datasetRSI.push(
				[data[i][0],RSI]
			);
		}
		
	}
	
	return [{
		data:	datasetRSI,
		name:	"RSI ("+options.period+")",
		type:	"spline",
		signal:	function(v) {
			if (v >= 70) {
				return -1;
			}
			if (v <= 30) {
				return 1;
			}
			return 0;
		}
	}];
};




indicators.DSP = {};
indicators.DSP.TwoPoleSuperSmoother = function(data, options) {
	var i,j;
	var buffer = new Array();
	
	var tempReal, rad2Deg, deg2Rad;
	var coef1, coef2, coef3;
	
	// init
	tempReal = Math.atan(1.0);
    rad2Deg = 45.0 / tempReal;
    deg2Rad = 1.0 / rad2Deg;
    var a1 = Math.exp(-1.414 * 3.14159 / options.CutoffPeriod);
    var b1 = 2 * a1 * Math.cos(deg2Rad * 1.414 * 180 / options.CutoffPeriod);
    coef2 = b1;
    coef3 = -a1 * a1;
    coef1 = 1.0 - coef2 - coef3;
	
	// main
	
	var l = data.length-options.CutoffPeriod-2;
	var debug = new Array();
	for (i=l;i>=0;i--) {
		if (!buffer[i+2] || !buffer[i+2]) {
			buffer[i] = [data[i][0],data[i][options.price]*1];
		} else {
			buffer[i] = [data[i][0],coef1 * data[i][options.price]*1+coef2 * buffer[i+1][1]+coef3 * buffer[i+2][1]];
		}
		if (!buffer[i]) {
			alert('TwoPoleSuperSmoother error at index '+i);
			break;
		}
	}
	
	return [{
		data:	buffer,
		name:	"TwoPoleSuperSmoother("+options.CutoffPeriod+")",
		type:	"spline"
	}];
}
indicators.DSP.InstaTrend = function(data, options) {
	
	options = _.extend({
		alpha: 		0.7,
		price: 		indicators.C
	}, options);
	
	var i,j;
	var EMA = new Array();
	var buffer = new Array();
	var l = data.length-1;
	for (i=l;i>=0;i--) {
		if (!EMA[i+2] || !EMA[i+1]) {
			EMA[i] = [data[i][0],data[i][options.price]*1];
		} else {
			EMA[i] = [data[i][0],((options.alpha-((options.alpha/2)*(options.alpha/2)))*data[i][options.price]*1+((options.alpha*options.alpha)/2)*data[i+1][options.price]*1-(options.alpha-(3*(options.alpha*options.alpha)/4))*data[i+2][options.price]*1+2*(1-options.alpha)*EMA[i+1][1]-((1-options.alpha)*(1-options.alpha))*EMA[i+2][1])];
		}
	}
	
	return [{
		data:	EMA,
		name:	"InstaTrend("+options.alpha+")",
		type:	"spline"
	}];
}
indicators.spectrum = {};
indicators.spectrum.InstaTrend = function(data, options) {
	
	options = _.extend({
		alpha: 		0.7,
		price: 		indicators.C,
		frequency:	[2,8,6]
	}, options);
	
	// colors
	var heatmap = new Rainbow();
	heatmap.setSpectrum('#3d83bb', '#903d3d', '#6e981d');
	heatmap.setNumberRange(0, options.frequency[2]);
	
	var i,j;
	var buffers = new Array();
	var c = 0;
	for (i=options.frequency[0];i<options.frequency[1];i+=(options.frequency[1]-options.frequency[0])/options.frequency[2]) {
		var buffer = indicators.DSP.InstaTrend(data, {price: options.price, alpha: i}) ;
		buffer[0].color = heatmap.colourAt(c++);
		buffers.push(buffer[0]);
	}
	
	return buffers;
}

exports.indicators = indicators;






















































// Non implemented yet


function dataEMA(data,from,to, period) {
	var i,j;
	var buffer = new Array();
	var pr = 2/(period+1);
	var l = data.length-1;
	for (i=l;i>=0;i--) {
		if (!buffer[i+1]) {
			buffer[i] = data[i];
		} else {
			buffer[i] = data[i]*pr+buffer[i+1]*(1-pr);
		}
	}
	var buffers = new Array();
	
	buffers.push({
		display:'chart',
		ns:'EMA',
		scale:'auto',
		array:buffer,
		type:'line',
		size:1,
		color:'255,255,255'
	});
	
	return {data:buffers};
}

function dataOscillator(data,from,to) {
	var i,j;
	var buffer = new Array();
	var l = data.length-1;
	for (i=l;i>=0;i--) {
		if (!buffer[i+1]) {
			buffer[i] = data[i];
		} else {
			buffer[i] = data[i]-data[i+1];
		}
	}
	/*alert(buffer);
	return 0;*/
	var buffers = new Array();
	
	buffers.push({
		display:'chart',
		ns:'Osc',
		scale:'auto',
		array:buffer,
		type:'line',
		size:1,
		color:'255,255,255'
	});
	
	return {data:buffers};
}

function XMA(data,from,to,periods,fntype,price,colorStr,type,size,ns) {
	var i,j;
	var fn;
	var buffers = new Array();
	switch (fntype) {
		case 'SMA':
		fn = SMA;
		break;
		case 'EMA':
		fn = EMA;
		break;
		case 'LWMA':
		fn = LWMA;
		break;
		case 'TwoPoleSuperSmoother':
		fn = TwoPoleSuperSmoother;
		break;
	}
	var t = new Array();
	var m = 255/periods.length;
	//for (i=0;i<periods.length;i++) {
	for (i=periods.length-1;i>=0;i--) {
		var buffer = fn(data,from,to, periods[i],price, null,null,null);
		buffers.push({
			display:'ext',
			ns:ns,
			scale:'chart',
			alpha:0.5,
			array:buffer.data[0].array,
			type:type,
			size:size,
			color:colorStr.replace("%c",r(i*m)).replace("%n",255-r(i*m))
		});
	}
	
	return {data:buffers};
}
function CummulativeOSC(data,from,to,periods,fntype,price,colorStr,type,size,ns) {
	var i,j;
	var fn;
	var buffers = new Array();
	var arrays = new Array();
	switch (fntype) {
		case 'SMA':
		fn = SMA;
		break;
		case 'EMA':
		fn = EMA;
		break;
		case 'LWMA':
		fn = LWMA;
		break;
		case 'TwoPoleSuperSmoother':
		fn = TwoPoleSuperSmoother;
		break;
	}
	var t = new Array();
	var m = 255/periods.length;
	//for (i=0;i<periods.length;i++) {
	for (i=periods.length-1;i>=0;i--) {
		var output = fn(data,from,to, periods[i],price, null,null,null);
		arrays.push(output.data[0].array);
	}
	var deep = arrays.length;
	var large = arrays[0].length;
	
	var sum = new Array();
	
	var tmp = "";
	
	for (i=0;i<large;i++) {
		sum[i] = 0;
	}
	for (i=0;i<large;i++) {
		for (j=0;j<deep;j++) {
			sum[i] += arrays[j][i];
		}
	}
	buffers.push({
		display:'ext',
		ns:ns,
		scale:'auto',
		alpha:0.5,
		array:dataOscillator(sum,from,to).data[0].array,
		type:type,
		size:size,
		color:colorStr.replace("%c",r(i*m)).replace("%n",255-r(i*m)),
		levels:[{
			color:'255,255,255',
			size:1,
			alpha:0.2,
			value:0.0
		}]
	});
	
	return {data:buffers};
}
function XOSC(data,from,to,periods,fntype,price,colorStr,type,size,ns) {
	var i,j;
	var fn;
	var buffers = new Array();
	var arrays = new Array();
	switch (fntype) {
		case 'SMA':
		fn = SMA;
		break;
		case 'EMA':
		fn = EMA;
		break;
		case 'LWMA':
		fn = LWMA;
		break;
		case 'TwoPoleSuperSmoother':
		fn = TwoPoleSuperSmoother;
		break;
	}
	var t = new Array();
	var m = 255/periods.length;
	//for (i=0;i<periods.length;i++) {
	for (i=0;i<periods.length;i++) {
		var rt = fn(data,from,to, periods[i],price, null,null,null).data[0].array;
		var output = dataOscillator(rt,from,to).data[0].array;
		arrays.push(output);
		buffers.push({
			display:'ext',
			ns:ns,
			scale:'indicator',
			alpha:0.5,
			array:output,
			type:type,
			size:size,
			color:colorStr.replace("%c",r(i*m)).replace("%n",255-r(i*m)),
			levels:[{
				color:'255,255,255',
				size:1,
				alpha:0.2,
				value:0.0
			}]
		});
	}
	/*var deep = arrays.length;
	var large = arrays[0].length;
	
	var sum = new Array();
	
	var tmp = "";
	
	for (i=0;i<large;i++) {
		sum[i] = 0;
	}
	for (i=0;i<large;i++) {
		for (j=0;j<deep;j++) {
			sum[i] += arrays[j][i];
		}
	}*/
	
	
	return {data:buffers};
}
function ITSpectrum(data,from,to,periods,price,colorStr,type,size,ns) {
	var i,j;
	var buffers = new Array();
	for (i=0;i<periods.length;i++) {
		//var buffer = EMA(data,from,to, periods[i],price, null,null,null);
		var buffer = InstaTrend(data,from,to, periods[i], price, null,null,null,null) ;
		buffers.push({
			display:'ext',
			ns:ns,
			scale:'chart',
			alpha:0.5,
			array:buffer.data[0].array,
			type:type,
			size:size,
			color:colorStr.replace("%c",((i)*(255/periods.length)))
		});
	}
	
	return {data:buffers};
}

function flatSpectrum(data,from,to,fn,periods,colorStr,ns) {
	var i,j;
	var buffers = new Array();
	for (i=0;i<periods.length;i++) {
		var tmp = fn.apply(this,[data,from,to]);
		var buffer = dataEMA(tmp.data[0].array,from,to, periods[i]);
		buffers.push({
			display:'ext',
			ns:ns,
			scale:'indicator',
			alpha:0.5,
			array:buffer.data[0].array,
			type:'line',
			size:1,
			color:colorStr.replace("%c",((i)*(255/periods.length))),
			levels:[{
				color:'255,255,255',
				size:1,
				alpha:0.2,
				value:0.0
			}]
		});
	}
	
	return {data:buffers};
}


function PriceRange(data,from,to,ns) {
	var i,j;
	var buffers = new Array();
	var buffer = new Array();
	var l = data.length;
	for (i=0;i<l;i++) {
		buffer.push(data[i].close-data[i].open);
	}
	
	buffers.push({
		display:'ext',
		ns:ns,
		scale:'auto',
		alpha:1.0,
		array:buffer,
		type:'bars',
		size:1,
		color:'255,255,255',
		levels:[{
			color:'255,255,255',
			size:1,
			alpha:0.2,
			value:0.0
		}]
	});
	
	return {data:buffers};
}

function stochastic(data,from,to,price,period,color,ns) {
	var i,j;
	var buffer = new Array();
	var buffers = new Array();
	var prices = getPrice(data,from,to,price,color,ns);
	buffer = dataStochatic(prices.data[0].array,from,to, period, ns);
	buffers.push({
		display:'ext',
		ns:ns,
		scale:'auto',
		alpha:1.0,
		array:buffer.data[0].array,
		type:'line',
		size:1,
		color:color,
		levels:[{
			color:'255,255,255',
			size:1,
			alpha:0.4,
			value:0.2
		},{
			color:'255,255,255',
			size:1,
			alpha:0.4,
			value:0.8
		},{
			color:'255,255,255',
			size:1,
			alpha:1,
			value:0.5
		}]
	});
	return {data:buffers};
}

function dataStochatic(data,from,to,period,ns) {
	var i,j;
	var buffers = new Array();
	var buffer = new Array();
	var l = data.length;
	for (i=0;i<l;i++) {
		var mm 		= array_maxmin_data(data,i,period);
		var sto 	= (data[i]-mm.min)/(mm.max-mm.min);
		buffer.push(sto);
	}
	
	buffers.push({
		display:'ext',
		ns:ns,
		scale:'auto',
		alpha:1.0,
		array:buffer,
		type:'bars',
		size:1,
		color:'255,255,255',
		levels:[{
			color:'255,255,255',
			size:1,
			alpha:0.2,
			value:0.0
		}]
	});
	
	return {data:buffers};
}


function getPrice(data,from,to,price,color,ns) {
	var i,j;
	var buffer = new Array();
	var buffers = new Array();
	var l = data.length;
	for (i=0;i<l;i++) {
		buffer.push(data[i][price]);
	}
	buffers.push({
		display:'ext',
		ns:ns,
		scale:'auto',
		alpha:0.5,
		array:buffer,
		type:'line',
		size:1,
		color:color
	});
	return {data:buffers};
}

function volumes(data,from,to,color,ns) {
	var i,j;
	var buffer = new Array();
	var buffers = new Array();
	var l = data.length;
	for (i=0;i<l;i++) {
		buffer.push(data[i].volume);
	}
	buffers.push({
		display:'ext',
		ns:ns,
		scale:'auto',
		alpha:0.5,
		array:buffer,
		type:'bars',
		size:1,
		color:color
	});
	return {data:buffers};
}

function InstaTrend(data,from,to, alpha, price, type, color, size, ns) {
	var i,j;
	var EMA = new Array();
	var buffer = new Array();
	var l = data.length-1;
	for (i=l;i>=0;i--) {
		if (!EMA[i+2] || !EMA[i+1]) {
			EMA[i] = data[i][price];
		} else {
			EMA[i] = ((alpha-((alpha/2)*(alpha/2)))*data[i][price]+((alpha*alpha)/2)*data[i+1][price]-(alpha-(3*(alpha*alpha)/4))*data[i+2][price]+2*(1-alpha)*EMA[i+1]-((1-alpha)*(1-alpha))*EMA[i+2]);
		}
	}
	var buffers = new Array();
	buffers.push({
		display:'ext',
		ns:ns,
		scale:'chart',
		array:EMA,
		type:type,
		size:size,
		color:color
	});
	
	return {data:buffers};
}

function mmbands(data,from,to, period, type, color, size) {
	var i,j;
	var bufferTop = new Array();
	var bufferBottom = new Array();
	var l = data.length-period;
	for (i=0;i<l;i++) {
		var mmHigh 		= array_maxmin(data,'high',i,period);
		var mmLow  		= array_maxmin(data,'low',i,period);
		bufferTop[i] 	= mmHigh.max;
		bufferBottom[i] = mmLow.min;
	}
	var buffers = new Array();
	buffers.push({
		display:'chart',
		ns:'mmbands1',
		scale:'chart',
		array:bufferTop,
		type:type,
		size:size,
		color:color
	});
	buffers.push({
		display:'chart',
		ns:'mmbands3',
		scale:'chart',
		array:bufferBottom,
		type:type,
		size:size,
		color:color
	});
	
	return {data:buffers};
}



/*
RainbowVis-JS 
Released under MIT License
*/

function Rainbow()
{
	var gradients = null;
	var minNum = 0;
	var maxNum = 100;
	var colours = ['ff0000', 'ffff00', '00ff00', '0000ff']; 
	setColours(colours);
	
	function setColours (spectrum) 
	{
		if (spectrum.length < 2) {
			throw new Error('Rainbow must have two or more colours.');
		} else {
			var increment = (maxNum - minNum)/(spectrum.length - 1);
			var firstGradient = new ColourGradient();
			firstGradient.setGradient(spectrum[0], spectrum[1]);
			firstGradient.setNumberRange(minNum, minNum + increment);
			gradients = [ firstGradient ];
			
			for (var i = 1; i < spectrum.length - 1; i++) {
				var colourGradient = new ColourGradient();
				colourGradient.setGradient(spectrum[i], spectrum[i + 1]);
				colourGradient.setNumberRange(minNum + increment * i, minNum + increment * (i + 1)); 
				gradients[i] = colourGradient; 
			}

			colours = spectrum;
		}
	}
	this.setColors = this.setColours;

	this.setSpectrum = function () 
	{
		setColours(arguments);
	}

	this.setSpectrumByArray = function (array)
	{
		setColours(array);
	}

	this.colourAt = function (number)
	{
		if (isNaN(number)) {
			throw new TypeError(number + ' is not a number');
		} else if (gradients.length === 1) {
			return gradients[0].colourAt(number);
		} else {
			var segment = (maxNum - minNum)/(gradients.length);
			var index = Math.min(Math.floor((Math.max(number, minNum) - minNum)/segment), gradients.length - 1);
			return gradients[index].colourAt(number);
		}
	}
	this.colorAt = this.colourAt;

	this.setNumberRange = function (minNumber, maxNumber)
	{
		if (maxNumber > minNumber) {
			minNum = minNumber;
			maxNum = maxNumber;
			setColours(colours);
		} else {
			throw new RangeError('maxNumber (' + maxNumber + ') is not greater than minNumber (' + minNumber + ')');
		}
	}
}

function ColourGradient() 
{
	var startColour = 'ff0000';
	var endColour = '0000ff';
	var minNum = 0;
	var maxNum = 100;

	this.setGradient = function (colourStart, colourEnd)
	{
		startColour = getHexColour(colourStart);
		endColour = getHexColour(colourEnd);
	}

	this.setNumberRange = function (minNumber, maxNumber)
	{
		if (maxNumber > minNumber) {
			minNum = minNumber;
			maxNum = maxNumber;
		} else {
			throw new RangeError('maxNumber (' + maxNumber + ') is not greater than minNumber (' + minNumber + ')');
		}
	}

	this.colourAt = function (number)
	{
		return calcHex(number, startColour.substring(0,2), endColour.substring(0,2)) 
			+ calcHex(number, startColour.substring(2,4), endColour.substring(2,4)) 
			+ calcHex(number, startColour.substring(4,6), endColour.substring(4,6));
	}
	
	function calcHex(number, channelStart_Base16, channelEnd_Base16)
	{
		var num = number;
		if (num < minNum) {
			num = minNum;
		}
		if (num > maxNum) {
			num = maxNum;
		} 
		var numRange = maxNum - minNum;
		var cStart_Base10 = parseInt(channelStart_Base16, 16);
		var cEnd_Base10 = parseInt(channelEnd_Base16, 16); 
		var cPerUnit = (cEnd_Base10 - cStart_Base10)/numRange;
		var c_Base10 = Math.round(cPerUnit * (num - minNum) + cStart_Base10);
		return formatHex(c_Base10.toString(16));
	}

	formatHex = function (hex) 
	{
		if (hex.length === 1) {
			return '0' + hex;
		} else {
			return hex;
		}
	} 
	
	function isHexColour(string)
	{
		var regex = /^#?[0-9a-fA-F]{6}$/i;
		return regex.test(string);
	}

	function getHexColour(string)
	{
		if (isHexColour(string)) {
			return string.substring(string.length - 6, string.length);
		} else {
			var colourNames =
			[
				['red', 'ff0000'],
				['lime', '00ff00'],
				['blue', '0000ff'],
				['yellow', 'ffff00'],
				['orange', 'ff8000'],
				['aqua', '00ffff'],
				['fuchsia', 'ff00ff'],
				['white', 'ffffff'],
				['black', '000000'],
				['gray', '808080'],
				['grey', '808080'],
				['silver', 'c0c0c0'],
				['maroon', '800000'],
				['olive', '808000'],
				['green', '008000'],
				['teal', '008080'],
				['navy', '000080'],
				['purple', '800080']
			];
			for (var i = 0; i < colourNames.length; i++) {
				if (string.toLowerCase() === colourNames[i][0]) {
					return colourNames[i][1];
				}
			}
			throw new Error(string + ' is not a valid colour.');
		}
	}
}

